Felipe Monsalve

Avery Nortonsmith

# 6.828 Project

For our 6.828 project, we worked on building a virtual machine monitor on top of xv6 capable of running unmodified xv6 instances. In our proposal, we talked about two main challenges that we would have to tackle: trap-and-emulate and memory translation. It turns out that while these were indeed two of the challenges we had to face, there were plenty more that popped up along the way. We started our project by looking into all of the possible illegal instructions and studying the possible side-effects - this task introduced new challenges, such as understanding the RISC-V hardware in great detail.

We approached the problem incrementally initially, first by loading a saved version of the unmodified xv6 binary as a user program in the host xv6 instance, and then by addressing problems as they appeared. This processes served both as a template for working towards a more functional virtual-machine monitor, and as a way of testing our system in real time. This work involved lots of work back-and-forth with the host and guest operating systems, using the debugger to step through the loading process for the guest OS and trying to understand the assumptions that xv6 makes about its environment.

One of the most open-ended aspects of the project was the emulation strategy - in particular figuring out how to keep track of the emulated state that the guest OS was running against. There were many situations where we filled in temporary functionality to allow the guest OS to get further in the boot process - for example telling the guest OS that it was always running on a single core, or storing the guest's attempts to interface with the hardware clock or UART without modifying the actual hardware configuration. This strategy helped us make initial progress in getting guest OS further along in development, but later on it became difficult to determine which bugs were caused by functionality that we hadn't implemented yet, or from flaws in our emulation accuracy.

In the end, there were a number of emulation components that we weren't able to fully implement (like forwarding clock interrupts to the guest OS, or completing the interface between the guest OS and the host UART), due to unresolved errors earlier in the loading process. Once we'd set up our host to intercept privileged instructions, our path forward was no longer a simple linear sequence of failing commands - instead we had to accommodate many different aspects of xv6 at once, including hardware interfaces, scheduling, and virtual memory. Whereas the initial trap-and-emulate implementation was relatively straightforward, we found it more difficult to handle these competing higher-level considerations simultaneously. The nature of our approach to this project - naively loading the guest OS as a user program and fixing bugs as they arose - meant that there was no point at which we were working with a non-buggy system.

However, there were a lot of challenges from which we learned immensely as we worked through the project. First of all, to even hope to make any progress on the project, we had to dig in and learn a lot about RISC-V’s ISA. As both Avery and I were very new to operating system engineering, this was a significant challenge that took a lot of the time we spent on the project, but it was no doubt a challenge we learned a lot from. In particular, we had to work closely with the RISC-V privileged ISA, and came to study a good amount of the control-and-status registers defined in the RISC-V specification. For each one, we had to understand how the hardware would use it, and whether we could completely emulate it in software, or whether we would need to use the hardware register while the guest operating system was running (for example, with the satp register for virtual memory emulation). Emulating the different instructions defined in the privileged ISA also gave us insight into all the side effects assembly instructions have in the RISC-V architecture. 

In the end, we have gotten quite far in the design of a trap-and-emulate virtual machine monitor, which handles the different privileged instructions in the RISC-V ISA, emulates the relevant CSRs for xv6, has some support for virtual paging emulation, some limited I/O support, and on which we tested, and believe we got close to, simulating hardware interrupts. Most of the code was implemented inside the usertrap handler, though we also had some code elsewhere, to help with emulation of different parts of hardware. We also believe that most of our VMM code could’ve easily supported multiple instances of xv6 running on a single RISC-V processor, without modification, but were unable to test this since xv6 doesn’t let us use the console with two simultaneous processes.

Looking forward, we believe there shouldn’t be too much more work left to see measurable improvement in how far xv6 will execute within our VMM before crashing. We have learned a lot about how an operating system operates within its processor, and more exploration into how to virtualize a processor will only keep teaching us more about this interaction. We will both keep exploring these challenges we have faced for the last few months, and hope to make even more progress later.
